!!
!! Reads in a file of amplitudes and phases for the 11 main tides in the BLQ format used by Scherneck
!!  and Bos for ocean loading, and outputs a time series of computed
!!  tidal displacments, using an expanded set of tidal constituents, whose
!!  amplitudes and phases are found by spline interpolation of the tidal
!!  admittance.  A total of 141 constituent tides are included, which gives
!!  a precision of about 1%
!!
!! See format statement 100, below, for a summary of usage
!!
!! Duncan Agnew, August 2005, based on the program   hartid  distributed
!!  with the SPOTL loading package.
!!
!! Corrected Nov 2005 (error in reading displacements)
!! Revised   Dec 2005 (Hartmann-Wenzel harmonics in admint)
!!
!! This software is freely provided for non-profit use only.  All commercial
!!  uses and any other restrictions or limitations imposed by third parties
!!  are forbidden.  No warranty is made or implied.
!!
!! Validation test data using hardisp.f routine:
!!  Test made by Jim Ray, 31 January 2006, using f90 compiler on HP-UX 11.11
!!  and verified by several other people using a variety of platforms.
!!
!!  Input ocean loading coefficients were generated by the ocean loading
!!  service on 30 January 2006 using http://www.oso.chalmers.se/~loading/
!!
!! UTC should be input
!
subroutine ocean_tidal_loading(jd, sod, olc, irnt, samp, wsz)
  implicit none
  include '../header/const.h'

  integer*4 jd, irnt
  real*8 sod, samp, olc(11, 6), wsz(1:*)
!
!! local
  integer*4 i, k, ntout, irli, irhi, np, idt(6, 11)
  real*8 f(141), pz(141), ps(141), pw(141), dr, scr(423)
  real*8 deg2rad, tamp(3, 11), tph(3, 11), amp(11), phase(11)
  real*8 az(141), hcz(282), as(141), hcs(282), aw(141), hcw(282)
  real*8 dz(600), ds(600), dw(600), wf(141)

  data dr/.01745329252d0/, irli/1/
!  Cartwright-Tayler numbers of tides used in Scherneck lists:
!      M2, S2, N2, K2, K1, O1, P1, Q1, Mf, Mm, Ssa
  data idt/ &
    2, 0, 0, 0, 0, 0, 2, 2, -2, 0, 0, 0, 2, -1, 0, 1, 0, 0, &
    2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, &
    1, 1, -2, 0, 0, 0, 1, -2, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, &
    0, 1, 0, -1, 0, 0, 0, 0, 2, 0, 0, 0/

  deg2rad = datan(1.d0)/45.d0
  do i = 1, 3
    tamp(i, 1:11) = olc(1:11, i)
    tph(i, 1:11) = -olc(1:11, i + 3)/deg2rad
  enddo

!*******************************************************************
!
!  find amplitudes and phases for all constituents, for each of the
!    three displacements. Note that the same frequencies are returned each
!    time
!  BLQ format order is vertical, horizontal EW, horizontal NS
!
!*******************************************************************
  do i = 1, 11
    amp(i) = tamp(1, i)
    phase(i) = tph(1, i)
  enddo
  call admint(jd, sod, amp, idt, phase, az, f, pz, ntout)
  do i = 1, 11
    amp(i) = tamp(2, i)
    phase(i) = tph(2, i)
  enddo
  call admint(jd, sod, amp, idt, phase, aw, f, pw, ntout)
  do i = 1, 11
    amp(i) = tamp(3, i)
    phase(i) = tph(3, i)
  enddo
  call admint(jd, sod, amp, idt, phase, as, f, ps, ntout)
!
!  set up for recursion, by normalizing frequencies, and converting
!  phases to radians
!
  do i = 1, ntout
    pz(i) = dr*pz(i)
    ps(i) = dr*ps(i)
    pw(i) = dr*pw(i)
    f(i) = samp*PI*f(i)/43200.d0
    wf(i) = f(i)
  enddo
!*******************************************************************
!
!  Loop over times, 600 output points at a time. At the start of each
!    such block, convert from amp and phase to sin and cos (hc array) at
!    the start of the block. The computation of values within each
!    block is done recursively, since the times are equi-spaced.
!
!*******************************************************************
  k = 1
31 irhi = min(irli + 599, irnt)
  np = irhi - irli + 1
! set up harmonic coefficients, compute tide, and write out
  do i = 1, 141
    hcz(2*i - 1) = az(i)*dcos(pz(i))
    hcz(2*i) = -az(i)*dsin(pz(i))
    hcs(2*i - 1) = as(i)*dcos(ps(i))
    hcs(2*i) = -as(i)*dsin(ps(i))
    hcw(2*i - 1) = aw(i)*dcos(pw(i))
    hcw(2*i) = -aw(i)*dsin(pw(i))
  enddo
  call recurs(dz, np, hcz, ntout, wf, scr)
  call recurs(ds, np, hcs, ntout, wf, scr)
  call recurs(dw, np, hcw, ntout, wf, scr)
!write(*,'(3f14.6)') (dw(i),ds(i),dz(i),i=1,np) !(dz(i),ds(i),dw(i),i=1,np)
  do i = 1, np
    wsz(k) = -dw(i)
    wsz(k + 1) = -ds(i)
    wsz(k + 2) = dz(i)
    k = k + 3
  enddo
  if (irhi .eq. irnt) return
  irli = irhi + 1
!  reset phases to the start of the new section
  do i = 1, 141
    pz(i) = dmod(pz(i) + np*f(i), 2.d0*PI)
    ps(i) = dmod(ps(i) + np*f(i), 2.d0*PI)
    pw(i) = dmod(pw(i) + np*f(i), 2.d0*PI)
  enddo
  goto 31
end

subroutine admint(jd, sod, ampin, idtin, phin, amp, f, p, nout)
  implicit none
!
!! Returns the amplitude, frequency, and phase of a set of tidal
!! constituents. n is input as the number wanted, and returned as the number
!! provided.  The constituents used are stored in the arrays idd (doodson
!! number) and tamp (Cartwright-Edden amplitude).  The actual amp and
!! phase of each of these are determined by spline interpolation of the
!! real and imaginary part of the admittance, as specified at a subset
!! of the constituents.
!! The phase is determined for a time set in common block /date/ (see
!! subroutine tdfrph), outside of this subroutine.
!!  Note that the arrays f and p must be specified as double precision.
!
  integer*4 jd, nout, idtin(6, 11)
  real*8 sod, ampin(11), phin(11), amp(141), f(141), p(141)
!
!! local
!  arrays containing information about all stored constituents: idd,tamp
  integer*4 i, j, k, ii, ll, kk, idd(6, 141), key(20), nlp, ndi, nsd, ntd
  real*8 dtr, re, am, sf, fr, pr, tamp(141)
! arrays containing information about the subset whose amp and phase may
! be specified, and scratch arrays for the spline routines at most 20 constituents may be specified.
  real*8 rl(20), aim(20), rf(20), scr(20), zdi(20), zdr(20), di(20), dr(20), sdi(20), sdr(20), tdi(20), tdr(20)
!
!! function called
  real*8 eval

  data dtr/.017453293/, rl/20*0.0/, aim/20*0.0/, rf/20*0.0/
  data zdi/20*0.0/, zdr/20*0.0/, di/20*0.0/, dr/20*0.0/, sdi/20*0.0/, sdr/20*0.0/, tdi/20*0.0/, tdr/20*0.0/
  data tamp/ &
    0.63221, .29411, .12105, .07991, .02382, -.02359, .02299, .01933, &
    -.01787, .01719, .01602, .00467, -.00466, -.00452, .00447, .00447, &
    0.00259, -.00246, -.00217, .00197, .00195, .00191, -.00190, .00180, &
    0.00130, .00117, .00113, .00106, -.00102, -.00102, .00101, .00090, &
    -.00086, .00085, .00085, .00077, .00074, .00074, -.00072, .00070, &
    0.00066, .00065, -.00065, .00063, .00063, -.00060, .00059, .00054, &
    0.00048, -.00046, .00041, .36864, -.26223, -.12200, -.05021, .05003, &
    -.04947, .02062, .02061, .01128, -.00953, -.00947, -.00801, .00741, &
    -.00730, .00723, -.00713, -.00664, .00525, .00414, .00409, .00394, &
    0.00394, .00342, .00342, .00289, .00288, .00216, -.00194, .00193, &
    -.00180, .00169, .00169, .00152, .00151, -.00151, .00138, .00137, &
    0.00137, -.00125, -.00107, .00102, .00090, .00087, -.00079, .00079, &
    0.00078, -.00075, -.00075, .00067, -.00060, -.00060, .00054, .00054, &
    -.00054, -.00047, -.00044, .00044, .00042, .00041, -.06661, -.03518, &
    -.03099, .02793, -.02762, -.01275, -.00673, -.00584, -.00529, -.00492, &
    -.00288, -.00258, -.00242, .00231, .00228, -.00204, .00188, -.00181, &
    -.00169, -.00100, -.00093, -.00084, .00077, .00077, -.00070, -.00050, &
    -.00049, .00049, .00048, .00044, -.00042/

  data idd/ &
    2, 0, 0, 0, 0, 0, 2, 2, -2, 0, 0, 0, 2, -1, 0, 1, 0, 0, &
    2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 1, 0, 2, 0, 0, 0, -1, 0, &
    2, -1, 2, -1, 0, 0, 2, -2, 2, 0, 0, 0, 2, 1, 0, -1, 0, 0, &
    2, 2, -3, 0, 0, 1, 2, -2, 0, 2, 0, 0, 2, -3, 2, 1, 0, 0, &
    2, 1, -2, 1, 0, 0, 2, -1, 0, 1, -1, 0, 2, 3, 0, -1, 0, 0, &
    2, 1, 0, 1, 0, 0, 2, 2, 0, 0, 2, 0, 2, 2, -1, 0, 0, -1, &
    2, 0, -1, 0, 0, 1, 2, 1, 0, 1, 1, 0, 2, 3, 0, -1, 1, 0, &
    2, 0, 1, 0, 0, -1, 2, 0, -2, 2, 0, 0, 2, -3, 0, 3, 0, 0, &
    2, -2, 3, 0, 0, -1, 2, 4, 0, 0, 0, 0, 2, -1, 1, 1, 0, -1, &
    2, -1, 3, -1, 0, -1, 2, 2, 0, 0, -1, 0, 2, -1, -1, 1, 0, 1, &
    2, 4, 0, 0, 1, 0, 2, -3, 4, -1, 0, 0, 2, -1, 2, -1, -1, 0, &
    2, 3, -2, 1, 0, 0, 2, 1, 2, -1, 0, 0, 2, -4, 2, 2, 0, 0, &
    2, 4, -2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, -2, 2, 0, -1, 0, &
    2, 2, -4, 0, 0, 2, 2, 2, -2, 0, -1, 0, 2, 1, 0, -1, -1, 0, &
    2, -1, 1, 0, 0, 0, 2, 2, -1, 0, 0, 1, 2, 2, 1, 0, 0, -1, &
    2, -2, 0, 2, -1, 0, 2, -2, 4, -2, 0, 0, 2, 2, 2, 0, 0, 0, &
    2, -4, 4, 0, 0, 0, 2, -1, 0, -1, -2, 0, 2, 1, 2, -1, 1, 0, &
    1, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 1, 1, -2, 0, 0, 0, &
    1, -2, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, -1, 0, 0, -1, 0, &
    1, 2, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 3, 0, 0, 0, 0, &
    1, -2, 2, -1, 0, 0, 1, -2, 0, 1, -1, 0, 1, -3, 2, 0, 0, 0, &
    1, 0, 0, -1, 0, 0, 1, 1, 0, 0, -1, 0, 1, 3, 0, 0, 1, 0, &
    1, 1, -3, 0, 0, 1, 1, -3, 0, 2, 0, 0, 1, 1, 2, 0, 0, 0, &
    1, 0, 0, 1, 1, 0, 1, 2, 0, -1, 1, 0, 1, 0, 2, -1, 0, 0, &
    1, 2, -2, 1, 0, 0, 1, 3, -2, 0, 0, 0, 1, -1, 2, 0, 0, 0, &
    1, 1, 1, 0, 0, -1, 1, 1, -1, 0, 0, 1, 1, 4, 0, -1, 0, 0, &
    1, -4, 2, 1, 0, 0, 1, 0, -2, 1, 0, 0, 1, -2, 2, -1, -1, 0, &
    1, 3, 0, -2, 0, 0, 1, -1, 0, 2, 0, 0, 1, -1, 0, 0, -2, 0, &
    1, 3, 0, 0, 2, 0, 1, -3, 2, 0, -1, 0, 1, 4, 0, -1, 1, 0, &
    1, 0, 0, -1, -1, 0, 1, 1, -2, 0, -1, 0, 1, -3, 0, 2, -1, 0, &
    1, 1, 0, 0, 2, 0, 1, 1, -1, 0, 0, -1, 1, -1, -1, 0, 0, 1, &
    1, 0, 2, -1, 1, 0, 1, -1, 1, 0, 0, -1, 1, -1, -2, 2, 0, 0, &
    1, 2, -2, 1, 1, 0, 1, -4, 0, 3, 0, 0, 1, -1, 2, 0, 1, 0, &
    1, 3, -2, 0, 1, 0, 1, 2, 0, -1, -1, 0, 1, 0, 0, 1, -1, 0, &
    1, -2, 2, 1, 0, 0, 1, 4, -2, -1, 0, 0, 1, -3, 3, 0, 0, -1, &
    1, -2, 1, 1, 0, -1, 1, -2, 3, -1, 0, -1, 1, 0, -2, 1, -1, 0, &
    1, -2, -1, 1, 0, 1, 1, 4, -2, 1, 0, 0, 0, 2, 0, 0, 0, 0, &
    0, 1, 0, -1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, &
    0, 2, 0, 0, 1, 0, 0, 3, 0, -1, 0, 0, 0, 1, -2, 1, 0, 0, &
    0, 2, -2, 0, 0, 0, 0, 3, 0, -1, 1, 0, 0, 0, 1, 0, 0, -1, &
    0, 2, 0, -2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 3, -2, 1, 0, 0, &
    0, 1, 0, -1, -1, 0, 0, 1, 0, -1, 1, 0, 0, 4, -2, 0, 0, 0, &
    0, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, -1, 0, 4, 0, -2, 0, 0, &
    0, 3, -2, 1, 1, 0, 0, 3, -2, -1, 0, 0, 0, 4, -2, 0, 1, 0, &
    0, 0, 2, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 4, 0, -2, 1, 0, &
    0, 3, 0, -1, 2, 0, 0, 5, -2, -1, 0, 0, 0, 1, 2, -1, 0, 0, &
    0, 1, -2, 1, -1, 0, 0, 1, -2, 1, 1, 0, 0, 2, -2, 0, -1, 0/
  k = 0
  nlp = 0
  ndi = 0
  nsd = 0
  ntd = 0
  do ll = 1, 11
!  see if Doodson numbers match
    do kk = 1, 141
      ii = 0
      do i = 1, 6
        ii = ii + iabs(idd(i, kk) - idtin(i, ll))
      enddo
      if (ii .eq. 0) exit
    enddo
!  have a match - put line into array
    if (ii .eq. 0 .and. k .lt. 20) then
      k = k + 1
      rl(k) = ampin(ll)*dcos(dtr*phin(ll))/dabs(tamp(kk))
      aim(k) = ampin(ll)*dsin(dtr*phin(ll))/dabs(tamp(kk))
! Now have real and imaginary parts of admittance, scaled by C-E
! amplitude. Admittance phase is whatever was used in the original
! expression. (Usually phase is given relative to some reference
! but amplitude is in absolute units). Next get frequency.
      call tdfrph(jd, sod, idd(1, kk), fr, pr)
      rf(k) = fr
    endif
  enddo
! done going through constituents--there are k of them
! have specified admittance at a number of points. sort these by frequency
! and separate diurnal and semidiurnal, recopying admittances to get them in
! order
  call shells(rf, key, k)
  do i = 1, k
    if (rf(i) .lt. 0.5) nlp = nlp + 1
    if (rf(i) .lt. 1.5 .and. rf(i) .gt. 0.5) ndi = ndi + 1
    if (rf(i) .lt. 2.5 .and. rf(i) .gt. 1.5) nsd = nsd + 1
    if (rf(i) .lt. 3.5 .and. rf(i) .gt. 2.5) ntd = ntd + 1
    scr(i) = rl(key(i))
  enddo
  do i = 1, k
    rl(i) = scr(i)
    scr(i) = aim(key(i))
  enddo
  do i = 1, k
    aim(i) = scr(i)
  enddo
!  now set up splines (8 cases - four species, each real and imag)
!  we have to allow for the case when there are no constituent amplitudes
!  for the long-period or terdiurnal.
  if (nlp .ne. 0) call spline(nlp, rf, rl, zdr, scr)
  if (nlp .ne. 0) call spline(nlp, rf, aim, zdi, scr)
  call spline(ndi, rf(nlp + 1), rl(nlp + 1), dr, scr)
  call spline(ndi, rf(nlp + 1), aim(nlp + 1), di, scr)
  call spline(nsd, rf(nlp + ndi + 1), rl(nlp + ndi + 1), sdr, scr)
  call spline(nsd, rf(nlp + ndi + 1), aim(nlp + ndi + 1), sdi, scr)
  if (ntd .ne. 0) call spline(ntd, rf(nlp + ndi + nsd + 1), rl(nlp + ndi + nsd + 1), tdr, scr)
  if (ntd .ne. 0) call spline(ntd, rf(nlp + ndi + nsd + 1), aim(nlp + ndi + nsd + 1), tdi, scr)
!  evaluate all harmonics using the interpolated admittance
  j = 1
  do i = 1, 141
    if ((idd(1, i) .eq. 0 .and. nlp .eq. 0) .or. (idd(1, i) .eq. 3 .and. ntd .eq. 0)) cycle
    call tdfrph(jd, sod, idd(1, i), f(j), p(j))
! equilibrium phase corrections (including to local phase)
    if (idd(1, i) .eq. 1) p(j) = p(j) + 90.d0
    if (idd(1, i) .eq. 3) p(j) = p(j) + 180.d0
    sf = f(j)
    if (idd(1, i) .eq. 0) re = eval(sf, nlp, rf, rl, zdr)
    if (idd(1, i) .eq. 0) am = eval(sf, nlp, rf, aim, zdi)
    if (idd(1, i) .eq. 1) re = eval(sf, ndi, rf(nlp + 1), rl(nlp + 1), dr)
    if (idd(1, i) .eq. 1) am = eval(sf, ndi, rf(nlp + 1), aim(nlp + 1), di)
    if (idd(1, i) .eq. 2) re = eval(sf, nsd, rf(nlp + ndi + 1), rl(nlp + ndi + 1), sdr)
    if (idd(1, i) .eq. 2) am = eval(sf, nsd, rf(nlp + ndi + 1), aim(nlp + ndi + 1), sdi)
    if (idd(1, i) .eq. 3) re = eval(sf, ntd, rf(nlp + ndi + nsd + 1), rl(nlp + ndi + nsd + 1), tdr)
    if (idd(1, i) .eq. 3) am = eval(sf, ntd, rf(nlp + ndi + nsd + 1), aim(nlp + ndi + nsd + 1), tdi)
    amp(j) = tamp(i)*dsqrt(re**2 + am**2)
    p(j) = p(j) + atan2(am, re)/dtr
    j = j + 1
  enddo
  nout = j - 1
  return
end

subroutine tdfrph(jd, sod, idood, freq, phase)
  implicit none
  include '../header/const.h'
!
!   Given the Doodson number of a tidal constituent (in idood), returns
!  the frequency and phase.  Phase is returned in degrees and frequency
!  in cycles/day.
!
!   Note that phases must be decreased by 90 degrees if the sum of the order
!  and the species number is odd (as for the 2nd degree diurnals, and 3rd
!  degree low-frequency and semidiurnals).
!   These phases may need further adjustment to allow for the spherical
!  harmonic normalization used; e.g. for that used for the potential by
!  Cartwright and Tayler, 180 degrees must be added for (species,order)
!  = (1,2), (1,3), or (3,3).
!
!  Common block date stores time information, in UT
!
!    calls toymd, leap, juldat, etutc (all for timekeeping)
!
  integer*4 jd, idood(6)
  real*8 sod, freq, phase
!
!! local
  integer*4 i, jdsav
  real*8 sodsav, t, f1, f2, f3, f4, f5
  real*8 fd1, fd2, fd3, fd4, fd5
  real*8 d(6), dd(6)
!
!! function called
  real*8 timdif, taiutc

  data jdsav, sodsav/0, 0.d0/
  save jdsav, sodsav, d, dd
!
!  test to see if time has changed; if so, set the phases and frequencies
!   for each of the Doodson arguments
!
  if (dabs(timdif(jd, sod, jdsav, sodsav)) .gt. MAXWND) then
    jdsav = jd
    sodsav = sod
!
! convert times to Julian days (UT) then to Julian centuries from J2000.00 (ET)
!
! call toymd(itm,itm2)
! jd = juldat(itm2)
! dayfr=  itm(3)/24.d0 + itm(4)/1440.d0 + itm(5)/84600.d0
! year=itm(1)+(itm(2)+dayfr)/(365+leap(itm(1)))
! call etutc(year,delta)
! djd= jd - 0.5d0 + dayfr
! t = (djd - 2451545.0d0 + delta/86400.d0)/36525.d0
    t = (jd - 51544.5d0 + (taiutc(jd) + 32.184d0)/86400.d0)/36525.d0
!
! IERS expressions for the Delauney arguments, in degrees
!
    f1 = 134.9634025100d0 + &
         t*(477198.8675605000d0 + &
            t*(0.0088553333d0 + &
               t*(0.0000143431d0 + &
                  t*(-0.0000000680d0))))
    f2 = 357.5291091806d0 + &
         t*(35999.0502911389d0 + &
            t*(-0.0001536667d0 + &
               t*(0.0000000378d0 + &
                  t*(-0.0000000032d0))))
    f3 = 93.2720906200d0 + &
         t*(483202.0174577222d0 + &
            t*(-0.0035420000d0 + &
               t*(-0.0000002881d0 + &
                  t*(0.0000000012d0))))
    f4 = 297.8501954694d0 + &
         t*(445267.1114469445d0 + &
            t*(-0.0017696111d0 + &
               t*(0.0000018314d0 + &
                  t*(-0.0000000088d0))))
    f5 = 125.0445550100d0 + &
         t*(-1934.1362619722d0 + &
            t*(0.0020756111d0 + &
               t*(0.0000021394d0 + &
                  t*(-0.0000000165d0))))
!
!  convert to Doodson (Darwin) variables
!
    d(1) = sod/86400.d0*360.d0 - f4
    d(2) = f3 + f5
    d(3) = d(2) - f4
    d(4) = d(2) - f1
    d(5) = -f5
    d(6) = d(3) - f2
!
!   find frequencies of Delauney variables (in cycles/day), and from these
!    the same for the Doodson arguments
!
    fd1 = 0.0362916471 + 0.0000000013*t
    fd2 = 0.0027377786
    fd3 = 0.0367481951 - 0.0000000005*t
    fd4 = 0.0338631920 - 0.0000000003*t
    fd5 = -0.0001470938 + 0.0000000003*t
    dd(1) = 1.d0 - fd4
    dd(2) = fd3 + fd5
    dd(3) = dd(2) - fd4
    dd(4) = dd(2) - fd1
    dd(5) = -fd5
    dd(6) = dd(3) - fd2
  endif
!
!   end of intialization (likely to be called only once)
!
!  compute phase and frequency of the given tidal constituent
!
  freq = 0.d0
  phase = 0.d0
  do i = 1, 6
    freq = freq + idood(i)*dd(i)
    phase = phase + idood(i)*d(i)
  enddo
! adjust phases to fall in the positive range 0 to 360
  phase = dmod(phase, 360.d0)
  if (phase .lt. 0.d0) phase = phase + 360.d0

  return
end

subroutine recurs(x, n, hc, nf, om, scr)
  implicit none
!  does sin and cos recursion to fill in data x, of length n, for
!  nf sines and cosines with frequenciies om (normalized so the
!  nyquist is pi). hc contains alternating cosine and sine coefficients
!  scr is a scratch array of length 3*nf (n.b. - it is double precision)
!
  integer*4 nf, n
  real*8 scr(1:*), x(1:*), hc(1:*), om(1:*)
!
!! local
  integer*4 i, j
  real*8 sc
!  set up for start of recursion by computing harmonic values
!  at start point and just before it
  do i = 1, nf
    scr(3*i - 2) = hc(2*i - 1)
    scr(3*i - 1) = hc(2*i - 1)*dcos(om(i)) - hc(2*i)*dsin(om(i))
    scr(3*i) = 2.d0*dcos(dble(om(i)))
  enddo
!  do recursion over data
  do i = 1, n
    x(i) = 0.d0
!  do recursive computation for each harmonic
    do j = 1, nf
      x(i) = x(i) + scr(3*j - 2)
      sc = scr(3*j - 2)
      scr(3*j - 2) = scr(3*j)*sc - scr(3*j - 1)
      scr(3*j - 1) = sc
    enddo
  enddo
  return
end

subroutine shells(x, k, n)
  implicit none
!
!! sorts an array x, of length n, sorting upward, and returns
!! an array k which may be used to key another array to the
!! sorted pattern (i.e., if we had an array f to which x
!! corresponded before sorting, then after calling shells,
!! f(k(1)) will be the element of f corresponding to the
!! smallest x, f(k(2)) the next smallest, and so on.
!!  revised 29-dec-82 so k is sorted in turn, the values of
!! k that point to identical values of x being put in increasing
!! order
!
  integer*4 n, k(n)
  real*8 x(n)
!
!! local
  integer*4 i, j, l, ik, iex, ipl, igap, imax
  real*8 sv

  igap = n
  do i = 1, n
    k(i) = i
  enddo
5 if (igap .le. 1) goto 25
  igap = igap/2
  imax = n - igap
10 iex = 0
  do i = 1, imax
    ipl = i + igap
    if (x(i) .le. x(ipl)) cycle
    sv = x(i)
    ik = k(i)
    x(i) = x(ipl)
    k(i) = k(ipl)
    x(ipl) = sv
    k(ipl) = ik
    iex = iex + 1
  enddo
  if (iex .gt. 0) goto 10
  goto 5
!
!  now sort k's (for identical values of x, if any)
!
25 j = 1
30 if (j .ge. n) return
  if (x(j) .eq. x(j + 1)) goto 33
  j = j + 1
  goto 30
!  have at least two x's with the same value - see how long this is true
33 l = j
35 if (x(l) .ne. x(l + 1)) goto 38
  l = l + 1
  if (l .lt. n) goto 35
!  j and l are the indices within which x(i) does not change - sort k
38 igap = l - j + 1
40 if (igap .le. 1) j = l + 1
  if (igap .le. 1) goto 30
  igap = igap/2
  imax = l - j + 1 - igap
45 iex = 0
  do i = 1, imax
    ipl = i + igap + j - 1
    if (k(i + j - 1) .le. k(ipl)) cycle
    ik = k(i + j - 1)
    k(i + j - 1) = k(ipl)
    k(ipl) = ik
    iex = iex + 1
  enddo
  if (iex .gt. 0) goto 45
  goto 40
end

subroutine spline(nn, x, u, s, a)
  implicit none
!$$$$calls no other routines
!  finds array  s  for spline interpolator  eval.
!  nn  number of data points supplied (may be negative, see below)
!  x  array containing x-coordinates where function is sampled.  xx(1),xx(2),...
!     must be a strictly increasing sequence.
!  u  array containing sample values that are to be interpolated.
!  s  output array of 2nd derivative at sample points.
!  a  working space array of dimension at least  nn.
!  if the user wishes to force the derivatives at the ends of the series to
!  assume specified values, he should put du(1)/dx and du(n)/dx in s1,s2
!  and call the routine with nn=-number of terms in series.  normally a parabola
!  is fitted through the 1st and last 3 points to find the slopes.
!  if less than 4 points are supplied, straight lines are fitted.
  integer*4 nn
  real*8 x(*), u(*), s(*), a(*)
!
!! local
  integer*4 i, j, n, n1
  real*8 q, u1, x1, u2, x2, q1, qn, c
!
!! function called
  q(u1, x1, u2, x2) = (u1/x1**2 - u2/x2**2)/(1.0/x1 - 1.0/x2)
!
  n = iabs(nn)
  if (n .le. 3) goto 5000
  q1 = q(u(2) - u(1), x(2) - x(1), u(3) - u(1), x(3) - x(1))
  qn = q(u(n - 1) - u(n), x(n - 1) - x(n), u(n - 2) - u(n), x(n - 2) - x(n))
  if (nn .gt. 0) goto 1000
  q1 = s(1)
  qn = s(2)
1000 s(1) = 6.d0*((u(2) - u(1))/(x(2) - x(1)) - q1)
  n1 = n - 1
  do i = 2, n1
    s(i) = (u(i - 1)/(x(i) - x(i - 1)) - u(i)*(1.0/(x(i) - x(i - 1)) + 1.0/(x(i + 1) - x(i))) + u(i + 1)/(x(i + 1) - x(i)))*6.d0
  enddo
  s(n) = 6.0*(qn + (u(n1) - u(n))/(x(n) - x(n1)))
  a(1) = 2.0*(x(2) - x(1))
  a(2) = 1.5*(x(2) - x(1)) + 2.0*(x(3) - x(2))
  s(2) = s(2) - 0.5*s(1)
  do i = 3, n1
    c = (x(i) - x(i - 1))/a(i - 1)
    a(i) = 2.d0*(x(i + 1) - x(i - 1)) - c*(x(i) - x(i - 1))
    s(i) = s(i) - c*s(i - 1)
  enddo
  c = (x(n) - x(n1))/a(n1)
  a(n) = (2.0 - c)*(x(n) - x(n1))
  s(n) = s(n) - c*s(n1)
!  back substitiute
  s(n) = s(n)/a(n)
  do j = 1, n1
    i = n - j
    s(i) = (s(i) - (x(i + 1) - x(i))*s(i + 1))/a(i)
  enddo
  return
!  series too short for cubic spline - use straight lines.
5000 do i = 1, n
    s(i) = 0.0
  enddo
  return
end

real*8 function eval(y, nn, x, u, s)
  implicit none
!$$$$calls no other routines
!  performs cubic spline interpolation of a function sampled at unequally
!  spaced intervals.  the routine spline  should be called to set up the array s
!  y  the coordinate at which function value is desired.
!  nn  number of samples of original function.
!  x  array containing sample coordinates. the sequence x(1),x(2).....x(nn)
!     must be strictly increasing.
!  u  array containing samples of function at the coordinates x(1),x(2)...
!  s  array containing the 2nd derivatives at the sample points.  found by the
!     routine  spline, which must be called once before beginning interpolation.
!  if  y  falls outside range(x(1),x(nn))  the value at the nearest endpoint
!  of the series is used.
  integer*4 nn
  real*8 y, x(1:*), u(1:*), s(1:*)
!
!! local
  integer*4 k1, k, istart
  real*8 dy, dy1, dk, deli, ff1, ff2, f1, f2, f3

  data istart/1/
!
  nn = iabs(nn)
  if (y .lt. x(1)) goto 3000
  if (y .gt. x(nn)) goto 3100
!  locate interval (x(k1),x(k))  containing y
  if (y - x(istart)) 1200, 1000, 1000
!  scan up the x array
1000 do k = istart, nn
    if (x(k) .gt. y) goto 1150
  enddo
1150 k1 = k - 1
  goto 1500
!  scan downwards in x array
1200 do k = 1, istart
    k1 = istart - k
    if (x(k1) .le. y) goto 1350
  enddo
1350 k = k1 + 1
1500 istart = k1
!  evaluate interpolate
  dy = x(k) - y
  dy1 = y - x(k1)
  dk = x(k) - x(k1)
  deli = 1.d0/(6.d0*dk)
  ff1 = s(k1)*dy*dy*dy
  ff2 = s(k)*dy1*dy1*dy1
  f1 = (ff1 + ff2)*deli
  f2 = dy1*((u(k)/dk) - (s(k)*dk)/6.)
  f3 = dy*((u(k1)/dk) - (s(k1)*dk)/6.0)
  eval = f1 + f2 + f3
  return
!  out of range.  substitute end values.
3000 eval = u(1)
  return
3100 eval = u(nn)
  return
end
